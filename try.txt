
# ==============================================================================
#               MERGED SMART PARKING & ANPR BARRIER SYSTEM
#               (Pins EXACTLY as per user's images, ANPR Buzzer moved)
# ==============================================================================
import cv2
import numpy as np
import pytesseract
import RPi.GPIO as GPIO
import time
from picamera2 import Picamera2
from RPLCD.gpio import CharLCD
import re
import os

# ==================================
#        CONFIGURATION & TUNING
# ==================================
DEBUG_MODE = True
DEBUG_IMG_PATH = "debug_images_merged"

# --- Camera (ANPR) ---
IMG_WIDTH = 1024
IMG_HEIGHT = 576

# --- Plate Extraction Tuning (ANPR) ---
CANNY_LOW_THRESH = 50
CANNY_HIGH_THRESH = 180
CONTOUR_APPROX_FACTOR = 0.02
MIN_PLATE_AREA = 500
MIN_ASPECT_RATIO = 1.8
MAX_ASPECT_RATIO = 5.5

# --- OCR Preprocessing Tuning (ANPR) ---
OCR_RESIZE_HEIGHT = 60
THRESHOLD_METHOD = 'ADAPTIVE'
ADAPT_THRESH_BLOCK_SIZE = 19 # Must be odd
ADAPT_THRESH_C = 9

# --- Tesseract Tuning (ANPR) ---
TESS_LANG = 'eng'
TESS_OEM = 3
TESS_PSM = '7'
TESS_WHITELIST = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
EXPECTED_PLATE_PATTERN = "" # Example: r"^[A-Z]{2}[0-9]{2}[A-Z]{3}$"

# --- OCR Post-Processing / Validation (ANPR) ---
MIN_PLATE_LENGTH = 5

# --- ANPR Main Loop Timing ---
PROCESS_COOLDOWN_ANPR = 8
RESET_TIMEOUT_ANPR = 15

# --- Parking System Configuration ---
CAR_PRESENT_THRESHOLD_CM = 30
SERVO_FREQUENCY = 50
SERVO_CLOSED_ANGLE = 0
SERVO_OPEN_ANGLE = 90
SERVO_MOVE_DELAY = 1.0
GATE_OPEN_DURATION_PARKING = 3.0
US_POLLING_INTERVAL = 1.0
IR_POLLING_INTERVAL_MAIN_LOOP = 0.1

# ==================================
#           PIN DEFINITIONS (BCM Mode) - MATCHING USER IMAGES
# ==================================
# --- LCD Pins ---
LCD_RS_PIN = 7    # BCM 7 (Physical 26)
LCD_E_PIN = 8     # BCM 8 (Physical 24)
LCD_D4_PIN = 25   # BCM 25 (Physical 22)
LCD_D5_PIN = 24   # BCM 24 (Physical 18)
LCD_D6_PIN = 23   # BCM 23 (Physical 16)
LCD_D7_PIN = 12   # BCM 12 (Physical 32)

# --- IR Sensor Pins (Parking System) ---
IR_ENTRY_PIN = 27 # BCM 27 (Physical 13)
IR_EXIT_PIN = 22  # BCM 22 (Physical 15)

# --- Servo Pins ---
SERVO_ENTRY_PIN = 17 # BCM 17 (Physical 11) - (Entry Gate, formerly ANPR BARRIER_PIN)
SERVO_EXIT_PIN = 4   # BCM 4  (Physical 7)  - (Exit Gate)

# --- ANPR Buzzer Pin ---
BUZZ_PIN_ANPR = 2    # BCM 2 (Physical 3) - *** MOVED FROM BCM 18 TO RESOLVE CONFLICT ***
                     # PLEASE VERIFY BCM 2 IS FREE ON YOUR PI (e.g., not actively used for I2C_SDA)

# --- Ultrasonic Sensor Pins (Parking System) ---
US_SENSORS = [
    {"name": "Slot 1", "trig": 5,  "echo": 6},    # TRIG=BCM5 (Phys 29), ECHO=BCM6 (Phys 31)
    {"name": "Slot 2", "trig": 19, "echo": 26},   # TRIG=BCM19(Phys 35), ECHO=BCM26(Phys 37)
    {"name": "Slot 3", "trig": 20, "echo": 21},   # TRIG=BCM20(Phys 38), ECHO=BCM21(Phys 40)
    {"name": "Slot 4", "trig": 16, "echo": 13},   # TRIG=BCM16(Phys 36), ECHO=BCM13(Phys 33)
    {"name": "Slot 5", "trig": 10, "echo": 9},    # TRIG=BCM10(MOSI)(Phys 19), ECHO=BCM9(MISO)(Phys 21)
    {"name": "Slot 6", "trig": 11, "echo": 18}    # TRIG=BCM11(SCLK)(Phys 23), ECHO=BCM18(PCM_CLK)(Phys 12)
]
TOTAL_PARKING_SPOTS = len(US_SENSORS)
# ==================================

# --- Create Debug Directory ---
if DEBUG_MODE and not os.path.exists(DEBUG_IMG_PATH):
    try:
        os.makedirs(DEBUG_IMG_PATH)
        print(f"Created debug directory: {DEBUG_IMG_PATH}")
    except OSError as e:
        print(f"[ERROR] Could not create debug directory '{DEBUG_IMG_PATH}': {e}")
        DEBUG_MODE = False

# --- Global Variables (Consolidated) ---
lcd = None
lcd_ready = False
picam2 = None
camera_ready = False
servo_entry_pwm = None
servo_exit_pwm = None
occupied_spots_status = [False] * TOTAL_PARKING_SPOTS
previous_occupied_spots_status = [False] * TOTAL_PARKING_SPOTS
available_spots_count = TOTAL_PARKING_SPOTS
last_us_poll_time = 0
entry_gate_busy = False
exit_gate_busy = False
anpr_last_processed_plate = ""
anpr_last_process_time = 0
anpr_last_plate_contour_detection_time = 0
anpr_processing_active = False

# --- LCD Setup Function ---
def setup_lcd():
    global lcd, lcd_ready
    try:
        lcd = CharLCD(
            numbering_mode=GPIO.BCM, cols=16, rows=2,
            pin_rs=LCD_RS_PIN, pin_e=LCD_E_PIN,
            pins_data=[LCD_D4_PIN, LCD_D5_PIN, LCD_D6_PIN, LCD_D7_PIN],
            charmap='A00', auto_linebreaks=True
        )
        lcd.clear()
        lcd_ready = True
        print("LCD Initialized Successfully.")
        lcd_display_merged("System Booting", "Please Wait...")
    except Exception as e:
        print(f"[ERROR] Failed to initialize LCD: {e}")
        lcd_ready = False
        class DummyLCD:
            def write_string(self, text): pass
            def clear(self): pass
            def cursor_pos(self, pos): pass
        lcd = DummyLCD()

def lcd_display_merged(line1, line2="", clear_first=True):
    if not lcd_ready: return
    try:
        if clear_first: lcd.clear()
        lcd.cursor_pos = (0, 0)
        lcd.write_string(str(line1)[:16])
        if line2:
            lcd.cursor_pos = (1, 0)
            lcd.write_string(str(line2)[:16])
    except Exception as e:
        print(f"[ERROR] LCD display error: {e}")

# --- Camera Setup (ANPR) ---
def setup_camera():
    global picam2, camera_ready
    try:
        picam2 = Picamera2()
        config = picam2.create_preview_configuration(main={"size": (IMG_WIDTH, IMG_HEIGHT)})
        picam2.configure(config)
        picam2.start()
        time.sleep(2.0)
        camera_ready = True
        print("Camera Initialized for ANPR.")
    except Exception as e:
        print(f"[ERROR] Failed to initialize Camera: {e}")
        camera_ready = False

# --- GPIO Setup ---
def setup_gpio():
    GPIO.setwarnings(False)
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(IR_ENTRY_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.setup(IR_EXIT_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    for sensor in US_SENSORS:
        GPIO.setup(sensor["trig"], GPIO.OUT)
        GPIO.setup(sensor["echo"], GPIO.IN)
        GPIO.output(sensor["trig"], False)
    GPIO.setup(SERVO_ENTRY_PIN, GPIO.OUT)
    GPIO.setup(SERVO_EXIT_PIN, GPIO.OUT)
    GPIO.setup(BUZZ_PIN_ANPR, GPIO.OUT, initial=GPIO.LOW) # Setup for new buzzer pin
    print("GPIO Initialized.")

# --- Servo Control (Parking System Based) ---
def setup_servos():
    global servo_entry_pwm, servo_exit_pwm
    try:
        servo_entry_pwm = GPIO.PWM(SERVO_ENTRY_PIN, SERVO_FREQUENCY)
        servo_exit_pwm = GPIO.PWM(SERVO_EXIT_PIN, SERVO_FREQUENCY)
        servo_entry_pwm.start(0)
        servo_exit_pwm.start(0)
        set_servo_angle_parking(servo_entry_pwm, SERVO_CLOSED_ANGLE, "Entry Initial")
        set_servo_angle_parking(servo_exit_pwm, SERVO_CLOSED_ANGLE, "Exit Initial")
        print("Servos Initialized and Closed.")
    except Exception as e:
        print(f"[ERROR] Failed to initialize servos: {e}")

def set_servo_angle_parking(servo_pwm, angle, gate_name_debug=""):
    if servo_pwm is None: return
    duty = (angle / 18.0) + 2.0
    servo_pwm.ChangeDutyCycle(duty)
    time.sleep(SERVO_MOVE_DELAY)
    servo_pwm.ChangeDutyCycle(0)

def open_gate_parking(servo_pwm_obj, gate_name):
    display_line1 = f"{gate_name} Gate"
    display_line2 = "Opening..."
    # If ANPR was just active, we might not want to clear its specific message immediately
    # This logic could be refined based on desired LCD flow during ANPR success
    clear_lcd = not (anpr_processing_active and gate_name == "Entry")
    lcd_display_merged(display_line1, display_line2, clear_first=clear_lcd)
    print(f"Opening {gate_name} gate...")
    set_servo_angle_parking(servo_pwm_obj, SERVO_OPEN_ANGLE, gate_name)
    print(f"{gate_name} gate OPEN.")

def close_gate_parking(servo_pwm_obj, gate_name):
    lcd_display_merged(f"{gate_name} Gate", "Closing...")
    print(f"Closing {gate_name} gate...")
    set_servo_angle_parking(servo_pwm_obj, SERVO_CLOSED_ANGLE, gate_name)
    print(f"{gate_name} gate CLOSED.")

# --- IR Sensor Functions ---
def read_ir_sensor(pin):
    return GPIO.input(pin) == GPIO.LOW

# --- Ultrasonic Sensor Functions ---
def measure_distance(trig_pin, echo_pin):
    GPIO.output(trig_pin, False); time.sleep(0.01)
    GPIO.output(trig_pin, True); time.sleep(0.00001); GPIO.output(trig_pin, False)
    start_time, end_time = time.time(), time.time()
    timeout_limit = 0.1; loop_start_time = time.time()
    while GPIO.input(echo_pin) == 0:
        start_time = time.time()
        if start_time - loop_start_time > timeout_limit: return float('inf')
    loop_start_time = time.time()
    while GPIO.input(echo_pin) == 1:
        end_time = time.time()
        if end_time - loop_start_time > timeout_limit: return float('inf')
    duration = end_time - start_time
    distance = (duration * 34300) / 2
    return distance if distance >= 0 else float('inf')

# --- ANPR Image Processing & OCR ---
# (perspective_transform, capture_image_anpr, plate_extraction_anpr,
# ocr_processing_anpr, check_database_anpr functions are largely unchanged
# from previous merged version, ensure they use the correct globals and debug paths)

def perspective_transform(image, pts): # From ANPR
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]; rect[2] = pts[np.argmax(s)]
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]; rect[3] = pts[np.argmax(diff)]
    (tl, tr, br, bl) = rect
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))
    if maxWidth <= 0 or maxHeight <= 0: return None
    dst = np.array([[0, 0], [maxWidth - 1, 0], [maxWidth - 1, maxHeight - 1], [0, maxHeight - 1]], dtype="float32")
    M = cv2.getPerspectiveTransform(rect, dst)
    return cv2.warpPerspective(image, M, (maxWidth, maxHeight))

def capture_image_anpr(): # From ANPR
    if not camera_ready: return None
    try:
        frame = picam2.capture_array("main")
        if frame.shape[2] == 4: frame = cv2.cvtColor(frame, cv2.COLOR_RGBA2BGR)
        else: frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
        return frame
    except Exception as e:
        print(f"[ERROR-ANPR] Image capture failed: {e}")
        return None

def plate_extraction_anpr(image): # From ANPR
    if image is None or image.size == 0: return None
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blur = cv2.bilateralFilter(gray, 11, 17, 17)
    edges = cv2.Canny(blur, CANNY_LOW_THRESH, CANNY_HIGH_THRESH)
    ts_for_debug = int(time.time()) # Get timestamp once for consistent naming
    if DEBUG_MODE: cv2.imwrite(os.path.join(DEBUG_IMG_PATH, f"{ts_for_debug}_anpr_01_edges.png"), edges)

    cnts, _ = cv2.findContours(edges.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[:10]
    plate_contour = None
    for c in cnts:
        perimeter = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, CONTOUR_APPROX_FACTOR * perimeter, True)
        if len(approx) == 4:
            (x, y, w, h) = cv2.boundingRect(approx)
            aspect_ratio = w / float(h) if h > 0 else 0
            area = cv2.contourArea(approx)
            if MIN_PLATE_AREA < area and MIN_ASPECT_RATIO < aspect_ratio < MAX_ASPECT_RATIO:
                plate_contour = approx
                if DEBUG_MODE:
                     debug_frame = image.copy(); cv2.drawContours(debug_frame, [plate_contour], -1, (0, 255, 0), 2)
                     cv2.imwrite(os.path.join(DEBUG_IMG_PATH, f"{ts_for_debug}_anpr_02_contour.png"), debug_frame)
                break
    if plate_contour is None: return None
    pts = plate_contour.reshape(4, 2)
    warped_plate = perspective_transform(gray, pts)
    if warped_plate is None or warped_plate.size == 0: return None
    if DEBUG_MODE: cv2.imwrite(os.path.join(DEBUG_IMG_PATH, f"{ts_for_debug}_anpr_03_warped.png"), warped_plate)
    return warped_plate

def ocr_processing_anpr(plate_image_gray): # From ANPR
    global anpr_last_plate_contour_detection_time # Ensure this global is updated
    if plate_image_gray is None or plate_image_gray.size == 0: return ""
    anpr_last_plate_contour_detection_time = time.time()

    try:
        h, w = plate_image_gray.shape[:2]
        aspect_ratio = w / float(h) if h > 0 else 1.0
        target_width = int(OCR_RESIZE_HEIGHT * aspect_ratio)
        plate_image_resized = cv2.resize(plate_image_gray, (target_width if target_width > 0 else w, OCR_RESIZE_HEIGHT), interpolation=cv2.INTER_LANCZOS4) if target_width > 0 else plate_image_gray
    except Exception as e:
        print(f"[WARN-ANPR] Plate resize failed: {e}. Using original.")
        plate_image_resized = plate_image_gray

    if THRESHOLD_METHOD == 'ADAPTIVE':
        binary_plate = cv2.adaptiveThreshold(plate_image_resized, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, ADAPT_THRESH_BLOCK_SIZE, ADAPT_THRESH_C)
    elif THRESHOLD_METHOD == 'OTSU':
        blurred = cv2.GaussianBlur(plate_image_resized, (5, 5), 0)
        _, binary_plate = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    else: # Default to adaptive
        binary_plate = cv2.adaptiveThreshold(plate_image_resized, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, ADAPT_THRESH_BLOCK_SIZE, ADAPT_THRESH_C)

    ts_for_debug = int(time.time())
    if DEBUG_MODE: cv2.imwrite(os.path.join(DEBUG_IMG_PATH, f"{ts_for_debug}_anpr_04_binary.png"), binary_plate)

    custom_config = f'--oem {TESS_OEM} --psm {TESS_PSM} -l {TESS_LANG}'
    if TESS_WHITELIST: custom_config += f' -c tessedit_char_whitelist={TESS_WHITELIST}'

    try:
        raw_text = pytesseract.image_to_string(binary_plate, config=custom_config)
        if DEBUG_MODE: print(f"  ANPR Raw OCR: '{raw_text.strip()}'")
        cleaned_text = ''.join(filter(str.isalnum, raw_text)).upper()

        if len(cleaned_text) < MIN_PLATE_LENGTH:
            if DEBUG_MODE and cleaned_text: print(f"  ANPR Reject (short): '{cleaned_text}'")
            return ""
        if EXPECTED_PLATE_PATTERN and not re.fullmatch(EXPECTED_PLATE_PATTERN, cleaned_text):
            if DEBUG_MODE: print(f"  ANPR Reject (pattern): '{cleaned_text}'")
            return ""
        return cleaned_text
    except pytesseract.TesseractNotFoundError: print("[ERROR-ANPR] Tesseract not found in PATH."); return ""
    except Exception as e: print(f"[ERROR-ANPR] OCR processing failed: {e}"); return ""

def check_database_anpr(plate_text): # From ANPR
    if not plate_text: return False
    try:
        with open('Database.txt', 'r') as f:
            database_plates = {line.strip().upper() for line in f if line.strip()}
        return plate_text in database_plates
    except FileNotFoundError:
        print("[ERROR-ANPR] Database.txt not found! Attempting to create empty one.")
        try:
            with open('Database.txt', 'w') as f: pass
            print("[INFO-ANPR] Created empty Database.txt.")
        except IOError: print("[ERROR-ANPR] Could not create Database.txt.")
        return False
    except Exception as e: print(f"[ERROR-ANPR] Database read error: {e}"); return False


# --- Parking System Logic ---
def update_parking_spots_status():
    global occupied_spots_status, previous_occupied_spots_status, available_spots_count, last_us_poll_time
    if time.time() - last_us_poll_time < US_POLLING_INTERVAL: return
    new_occupied_count = 0; changed_slots = False
    for i, sensor_info in enumerate(US_SENSORS):
        dist = measure_distance(sensor_info["trig"], sensor_info["echo"])
        current_spot_is_occupied = (dist < CAR_PRESENT_THRESHOLD_CM)
        if current_spot_is_occupied != previous_occupied_spots_status[i]:
            changed_slots = True
            print(f"PARKING: Slot {sensor_info['name']} is now {'OCCUPIED' if current_spot_is_occupied else 'EMPTY'} (Dist: {dist:.1f}cm)")
        occupied_spots_status[i] = current_spot_is_occupied
        if current_spot_is_occupied: new_occupied_count += 1
    available_spots_count = TOTAL_PARKING_SPOTS - new_occupied_count
    if changed_slots or (time.time() - last_us_poll_time >= US_POLLING_INTERVAL * 1.5):
        previous_occupied_spots_status = list(occupied_spots_status)
    last_us_poll_time = time.time()

def display_parking_main_status_lcd():
    global available_spots_count
    if anpr_processing_active or entry_gate_busy or exit_gate_busy: return # Don't overwrite active messages
    status_line1 = "Spots Available"
    status_line2 = f"{available_spots_count} Free"
    if available_spots_count == TOTAL_PARKING_SPOTS: status_line1 = "Parking Empty"
    elif available_spots_count == 0: status_line1 = "Parking Full!"; status_line2="No Spots Free"
    lcd_display_merged(status_line1, status_line2)

# --- MERGED Main Logic ---
def run_anpr_entry_sequence():
    global anpr_last_processed_plate, anpr_last_process_time, anpr_processing_active
    global available_spots_count, entry_gate_busy # Removed anpr_last_plate_contour_detection_time from globals here, it's updated in OCR

    print("\nANPR: Car detected at entry. Initiating plate recognition...")
    lcd_display_merged("Car at Entry", "Reading Plate...")

    frame_color = capture_image_anpr()
    if frame_color is None:
        lcd_display_merged("Camera Error", "Try Again Soon")
        print("ANPR: Failed to capture frame for entry.")
        time.sleep(2); return False

    extracted_plate_img_gray = plate_extraction_anpr(frame_color)

    if extracted_plate_img_gray is not None:
        plate_text_ocr = ocr_processing_anpr(extracted_plate_img_gray) # This updates anpr_last_plate_contour_detection_time

        if plate_text_ocr:
            current_time = time.time()
            if (current_time - anpr_last_process_time > PROCESS_COOLDOWN_ANPR) or \
               (plate_text_ocr != anpr_last_processed_plate):
                print(f"ANPR Detected: '{plate_text_ocr}'", end=' ')
                lcd_display_merged("Plate: " + plate_text_ocr, "Checking DB...")
                if check_database_anpr(plate_text_ocr):
                    if available_spots_count > 0:
                        print("[REGISTERED] ✅ Access Granted!")
                        lcd_display_merged(plate_text_ocr, "Access Granted")
                        GPIO.output(BUZZ_PIN_ANPR, GPIO.HIGH); time.sleep(0.5); GPIO.output(BUZZ_PIN_ANPR, GPIO.LOW)
                        # Entry gate sequence starts
                        open_gate_parking(servo_entry_pwm, "Entry")
                        time.sleep(GATE_OPEN_DURATION_PARKING)
                        close_gate_parking(servo_entry_pwm, "Entry")
                        # Entry gate sequence ends
                        print(f"ANPR -> Granted '{plate_text_ocr}'. Cooldown started.")
                        anpr_last_processed_plate = plate_text_ocr
                        anpr_last_process_time = time.time()
                        return True # Success
                    else: # Registered but full
                        print("[REGISTERED] BUT PARKING FULL ❌ Access Denied!")
                        lcd_display_merged(plate_text_ocr, "Parking Full!")
                else: # Unregistered
                    print("[UNREGISTERED] ❌ Access Denied!")
                    lcd_display_merged(plate_text_ocr, "Access Denied")
                # Common actions for denied (full or unregistered) or if just processed for cooldown
                if plate_text_ocr != anpr_last_processed_plate or (current_time - anpr_last_process_time > PROCESS_COOLDOWN_ANPR): # check if this denial is a new "process"
                    for _ in range(3): GPIO.output(BUZZ_PIN_ANPR, GPIO.HIGH); time.sleep(0.1); GPIO.output(BUZZ_PIN_ANPR, GPIO.LOW); time.sleep(0.1)
                    time.sleep(1.5) # Show denied message
                    print(f"ANPR -> Denied '{plate_text_ocr}'. Cooldown started.")
                    anpr_last_processed_plate = plate_text_ocr
                    anpr_last_process_time = time.time()
                return False # Failure
            else: # Cooldown active or same plate
                print(f"ANPR: Ignoring '{plate_text_ocr}' (cooldown/repeat).")
        else: # OCR failed
            print("ANPR: Contour found, OCR failed.")
            lcd_display_merged("Plate Found", "OCR Failed"); time.sleep(1.5)
    else: # No plate contour
        print("ANPR: No plate detected.")
        lcd_display_merged("No Plate Found", "Try Reposition"); time.sleep(1.5)
    return False # Default to failure

def merged_main_loop():
    global entry_gate_busy, exit_gate_busy, anpr_processing_active
    global anpr_last_processed_plate, anpr_last_plate_contour_detection_time

    current_time = time.time()

    if current_time - anpr_last_plate_contour_detection_time > RESET_TIMEOUT_ANPR:
        if anpr_last_processed_plate != "":
            print(f"\nANPR: No plate contour seen for {RESET_TIMEOUT_ANPR}s. Resetting ANPR lock.")
            anpr_last_processed_plate = ""
            anpr_last_plate_contour_detection_time = current_time
            # Update LCD only if no other process is controlling it
            if not (anpr_processing_active or entry_gate_busy or exit_gate_busy):
                 lcd_display_merged("System Ready", f"{available_spots_count} Spots")


    entry_ir_active = read_ir_sensor(IR_ENTRY_PIN)
    if entry_ir_active and not entry_gate_busy and not anpr_processing_active:
        anpr_processing_active = True # Set ANPR busy flag
        entry_gate_busy = True      # Set entry gate busy flag
        run_anpr_entry_sequence()   # This function will handle the gate and reset flags
        anpr_processing_active = False # Reset ANPR busy after sequence
        entry_gate_busy = False      # Reset entry gate busy after sequence
        # LCD should be updated by run_anpr or by display_parking_main_status_lcd if nothing else is active


    exit_ir_active = read_ir_sensor(IR_EXIT_PIN)
    if exit_ir_active and not exit_gate_busy and not entry_gate_busy and not anpr_processing_active:
        exit_gate_busy = True
        print("PARKING: Car detected at exit.")
        open_gate_parking(servo_exit_pwm, "Exit")
        lcd_display_merged("Car Exiting", "Goodbye!") # This is okay as exit doesn't involve ANPR messages prior
        time.sleep(GATE_OPEN_DURATION_PARKING)
        close_gate_parking(servo_exit_pwm, "Exit")
        exit_gate_busy = False

    update_parking_spots_status()
    if not (entry_gate_busy or exit_gate_busy or anpr_processing_active):
        display_parking_main_status_lcd()


# --- Main Execution ---
if __name__ == "__main__":
    try:
        # Initial Tesseract Check
        try:
            tesseract_version = pytesseract.get_tesseract_version()
            print(f"Tesseract version: {tesseract_version}")
        except pytesseract.TesseractNotFoundError:
            print("[FATAL ERROR] Tesseract not installed or not found. sudo apt install tesseract-ocr")
            exit(1)

        # Initial Database Check
        try:
            with open('Database.txt', 'r') as f: print(f"Database.txt found ({len(f.readlines())} entries).")
        except FileNotFoundError:
            print("[WARNING] Database.txt not found. Creating empty one.")
            try:
                with open('Database.txt', 'w') as f: pass
            except IOError as e: print(f"[ERROR] Could not create Database.txt: {e}")

        setup_gpio()
        setup_lcd()
        setup_camera()
        setup_servos()

        if not camera_ready:
            lcd_display_merged("ANPR Cam FAIL!", "Entry Disabled")
            print("[CRITICAL] ANPR Camera failed. Entry via ANPR will not work.")
            # Decide if to continue with parking functions only or exit
            # For now, we'll let it continue for parking spot & exit functionality.

        # Initialize ANPR contour detection time to current time to prevent immediate reset
        anpr_last_plate_contour_detection_time = time.time()
        lcd_display_merged("System Ready", f"{available_spots_count} Spots Free")
        print("Combined Parking & ANPR System Ready. Press Ctrl+C to quit.")
        time.sleep(2)

        while True:
            merged_main_loop()
            time.sleep(IR_POLLING_INTERVAL_MAIN_LOOP)

    except KeyboardInterrupt:
        print("\nCtrl+C Detected. Exiting Program...")
    except Exception as e:
        print(f"An unexpected critical error occurred: {e}")
        import traceback
        traceback.print_exc()
    finally:
        print("Cleaning up all resources...")
        if lcd_ready and lcd:
            lcd_display_merged("System Offline", "Goodbye!", clear_first=True)
            time.sleep(1);
            try: lcd.clear()
            except: pass
        if servo_entry_pwm: servo_entry_pwm.stop()
        if servo_exit_pwm: servo_exit_pwm.stop()
        if camera_ready and picam2:
            try: picam2.stop(); print("Camera stopped.")
            except: pass
        GPIO.cleanup()
        print("GPIO Cleaned Up. Exited.")
